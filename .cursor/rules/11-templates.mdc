---
description: Code templates (paste-ready)
alwaysApply: false
---

# Axum route (Invoke)
```rust
// @template-api-invoke.rs
pub async fn invoke(Path(name): Path<String>, headers: HeaderMap, body: Bytes, State(svc): State<App>) -> impl IntoResponse {
    let itype = headers.get("X-Amz-Invocation-Type").and_then(|v| v.to_str().ok()).unwrap_or("RequestResponse");
    let logtype = headers.get("X-Amz-Log-Type").and_then(|v| v.to_str().ok()).unwrap_or("None");
    let req = InvokeRequest { name, payload: body.to_vec(), invocation_type: itype.into(), log_type: logtype.into() };
    match svc.control.invoke(req).await {
        Ok(r) => {
            let mut resp = Response::builder().status(StatusCode::OK);
            if let Some(err) = r.function_error { resp = resp.header("X-Amz-Function-Error", err); }
            if let Some(tail) = r.log_tail_b64 { resp = resp.header("X-Amz-Log-Result", tail); }
            resp.body(Body::from(r.payload)).unwrap()
        }
        Err(InvokeErr::Throttled) => (StatusCode::TOO_MANY_REQUESTS, "Throttled").into_response(),
        Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()).into_response(),
    }
}

// @template-runtime-next.rs
pub async fn next(State(svc): State<App>, Query(q): Query<NextQ>) -> impl IntoResponse {
    // Blocks until an event is available for the requesting container/runtime
    let ev = svc.control.dequeue_for_container(/* container identity */).await?;
    Json(ev)
}

// @template-invoker-start.rs
pub async fn start_container(args: StartArgs) -> Result<Started, Error> {
    use bollard::container::*;
    // create + start; set resources, env, cmd
    // attach logs, return container_id
    Ok(Started { id, warm: false })
}

// @template-idle-watchdog.rs
pub async fn run_idle_watchdog(ctrl: Control) {
    loop {
        ctrl.reap_soft_idle().await;
        ctrl.reap_hard_idle().await;
        tokio::time::sleep(Duration::from_secs(5)).await;
    }
}